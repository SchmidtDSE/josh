# Josh Language

Josh is a domain-specific language (DSL) designed for ecological modeling, with a particular focus on vegetation and agent-based simulations. The language enables the description of multi-occupancy patch-based ecological simulations where multiple species occupying grid cells can be modeled through individual behaviors with optional state changes.

## Purpose

Josh supports the nexus between science, policy, and software engineering by executing vegetation-focused ecological simulations to support management decisions. The language prioritizes readability and interpretability for a broad audience including ecologists, policy makers, and researchers who may not have extensive software engineering backgrounds.

## Execution Environments

Josh runs across multiple execution environments without requiring code changes:

1. **Browser via WebAssembly**: Complete simulations run directly in web browsers using WebAssembly compilation via TeaVM, requiring no local installation
2. **Local JVM**: High-performance execution on local machines using Java Virtual Machine for intensive computations and parallelization
3. **Distributed via JoshCloud**: Community infrastructure for large-scale distributed processing across multiple machines with API key access

## Geospatial Data Preprocessing

Josh supports preprocessing of external geospatial data files into an optimized binary format called `.jshd` (Josh Data) files. The preprocessing workflow converts data from formats like GeoTIFF and NetCDF into a format optimized for simulation execution, handling coordinate system transformations, temporal alignment, and spatial resampling.

Preprocessing command structure:
```
java -jar joshsim.jar preprocess simulation.josh SimulationName data.nc variable units output.jshd
```

## Language Structure

Josh uses a stanza-based approach similar to SmallTalk/HyperTalk languages. Each stanza defines an entity (object) using `start` and `end` blocks. The language is imperative with procedural elements, prioritizing behavioral description over computational specification.

### Entity Types

- **simulation**: Defines simulation parameters, grid specifications, time steps, and export configurations
- **patch**: Represents spatial cells containing organisms and environmental conditions
- **organism**: Individual agents with attributes and behaviors that change over time
- **disturbance**: Events that affect organisms or patches (e.g., fire, drought)
- **management**: Intentional interventions and management actions
- **external**: References to external data sources and resources
- **unit**: Custom unit definitions with conversions and aliases

### Stanza Structure

Each entity stanza follows this pattern:
```
start <entity_type> <identifier>
  <attribute>.<event> = <expression>
  <attribute>.<event>:<conditional> = <expression>
end <entity_type>
```

### Events

- **init**: Initialization event, executed once at entity creation
- **step**: Step event, executed each simulation timestep
- **end**: Termination event, executed when entity is removed

## Language Features

### Comments
Single-line comments use `#` syntax:
```
# This is a comment
```

### Data Types

#### Scalar Values
Numeric values with optional units:
```
5 meters
10.5 years
42 count
33.7 degrees latitude
```

#### Strings
String literals enclosed in double quotes:
```
"Default"
"file:///tmp/output.csv"
```

#### Boolean Values
```
true
false
```

#### Distributions
Statistical distributions for stochastic modeling:
```
uniform from 0 meters to 1 meters
normal with mean of 10 years std of 2 years
```

### Unit System

Units are strongly typed and support conversions:

#### Built-in Units
- **Percentage**: `%`, `percent`
- **Count**: `count`, `counts`
- **Degrees**: `degrees`, `degree` (for latitude/longitude)
- **Meters**: `meter`, `meters`, `m`
- **Kilometers**: `kilometer`, `kilometers`, `km`
- **Boolean**: `bool`
- **String**: `string`

#### Custom Units
```
start unit year
  alias years
  alias yr
  alias yrs
end unit
```

#### Unit Conversions
```
start unit inch
  meter = 0.0254 meters
end unit
```

### Identifiers and Attributes

Identifiers follow the pattern `[A-Za-z][A-Za-z0-9]*` and can be chained with dot notation:
```
organism.attribute
patch.ForeverTree.age
current.height
```

### Keywords and Context

#### Temporal Keywords
- **current**: Current state of entity
- **prior**: State from previous timestep
- **meta**: Simulation metadata and context
  - `meta.stepCount`: Current simulation timestep (0-based)
  - `meta.year`: Current simulation year

#### Spatial Keywords
- **here**: Current grid cell context
- **within**: Spatial query for nearby entities

### Operators

#### Arithmetic Operators
- `+`: Addition
- `-`: Subtraction
- `*`: Multiplication
- `/`: Division
- `^`: Exponentiation
- `%`: Modulo

#### Comparison Operators
- `==`: Equality
- `!=`: Inequality
- `>`: Greater than
- `>=`: Greater than or equal
- `<`: Less than
- `<=`: Less than or equal

#### Logical Operators
- `and`: Logical AND
- `or`: Logical OR
- `xor`: Logical XOR

#### String Operator
- `|`: String concatenation

### Expressions

#### Function Calls
```
function_name(arguments)
mean(ForeverTree.age)
sample(uniform from 0 to 10)
```

#### Built-in Functions
- **mean()**: Calculate mean of collection
- **std()**: Calculate standard deviation
- **count()**: Count elements in collection
- **sample()**: Sample from distribution or collection
- **create**: Create new entities
- **force**: Type conversion

#### Collection Operations
```
ForeverTree[ForeverTree.age > 5 years]  # Filtering
all  # All entities of specified type
```

### Control Flow

#### Conditional Modifiers
Event handlers can use conditional modifiers:
```
attribute.event:if(condition) = expression
attribute.event:elif(condition) = expression
attribute.event:else = expression
```

#### Conditional Expressions
Ternary-style conditional expressions:
```
value if condition else alternative
```

#### Full Body Conditionals
Multi-statement conditional blocks:
```
if condition {
  const temp = prior.value
  return temp + 1
} elif other_condition {
  return prior.value
} else {
  return 0
}
```

### Full Bodies

Multi-statement blocks enclosed in curly braces `{}` supporting:
- `const` variable declarations
- `return` statements
- Conditional blocks
- Complex logic

Example:
```
age.step = {
  const currentAge = prior.age
  const increment = 1 year
  return currentAge + increment
}
```

### Operations

#### Sampling
```
sample uniform from low to high
sample count from collection
sample count from collection with replacement
sample count from collection without replacement
```

#### Limiting
```
limit operand to [min,]      # Minimum bound
limit operand to [,max]      # Maximum bound
limit operand to [min,max]   # Both bounds
```

#### Mapping
```
map operand from [fromlow,fromhigh] to [tolow,tohigh]
map operand from [fromlow,fromhigh] to [tolow,tohigh] method
map operand from [fromlow,fromhigh] to [tolow,tohigh] method(argument)
```

#### Creation
```
create EntityType                    # Create single entity
create count of EntityType          # Create multiple entities
```

### Spatial Queries

```
identifier within distance radial at prior
```

### Imports and Configuration

#### Imports
```
import "filename.josh"
```

#### Configuration
```
config expression as identifier
```

### Assertions

Validation statements for testing and debugging:
```
assert.attribute.event = boolean_expression
assert.attribute.event:if(condition) = boolean_expression
```

Assertions expect boolean values and are evaluated during event handler execution.

### Exports

Define simulation outputs:
```
export.variable.event = expression
exportFiles.type = "output_path"
```

### State Management

Entities can define custom states:
```
start state "StateName"
  attribute.event = expression
end state
```

### Reserved Words

The following keywords are reserved and should not be used for user-defined entities or variables:
`as`, `const`, `disturbance`, `elif`, `else`, `end`, `if`, `management`, `limit`, `map`, `return`, `start`, `state`, `step`, `within`

### Program Structure

A complete Josh program consists of:
1. Optional configuration statements
2. Optional import statements  
3. Unit definitions
4. Entity stanzas (simulation, patch, organism, etc.)

Example minimal program:
```
start simulation Main
  grid.size = 1000 m
  grid.low = 33.7 degrees latitude, -115.4 degrees longitude
  grid.high = 34.0 degrees latitude, -116.4 degrees longitude
  steps.low = 0 count
  steps.high = 10 count
end simulation

start patch Default
  ForeverTree.init = create 10 count of ForeverTree
end patch

start organism ForeverTree
  age.init = 0 year
  age.step = prior.age + 1 year
end organism

start unit year
  alias years
end unit
```

This language specification covers all features defined in the Josh grammar and provides comprehensive documentation for developing ecological simulations using the Josh domain-specific language.