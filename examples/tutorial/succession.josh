###
# Simple successional model to demonstrate agentic modeling in Josh
#
# Simple successional model to demonstrate agentic modeling in Josh in response to external data
# files. This is further described in succession.md with equations provided. Note that this is
# verbose in a few areas for readability. Used in agentic modeling tutorial.
#
# Toy model not meant to be ecologically sound or verified. Geospatial coordinates only provided to
# demonstrate use with external data.
#
# License: BSD-3-Clause
# Data: Cal-Adapt
###


start simulation Main

  # Specify where the simluation runs
  grid.size = 100 m
  grid.low = 36.52 degrees latitude, -118.68 degrees longitude
  grid.high = 36.42 degrees latitude, -118.45 degrees longitude

  # Specify when the simulation runs (2024 to 2054)
  steps.low = 0 count
  steps.high = 30 count

  startYear.init = 2024
  year.init = startYear
  year.step = prior.year + 1 

  # Indicate ecological and spatial limits
  constraints.maxOccupants = 10 count
# Comment: Note that with the 100 m grid cell this is now quite sparse. Not a problem for the tutorial I think, but just to keep in mind (e.g. I don't think light competition would drive sucession here because we do not necessarily have a closed canopy)
  constraints.minViableTemperature = 273 K
  constraints.maxViableTemperature = 373 K

  optimal.temperature.speciesA = 300 K
  optimal.temperature.speciesB = 320 K
  optimal.precip.speciesA = 500 mm
  optimal.precip.speciesB = 400 mm

  survival.speciesA = 30%
  survival.speciesB = 50%

# Comment: I can't yet map these completely to our functions, especially precipitationBase. Not also inconsistency in naming (Scaler vs Scale)?
# Comment on comment: Got it now, it is e :)
  growthScaler = 0.0025 m / (1 K * 1 K)
  precipitationBase = 2.7182818284
  precipitationScale = 0.0025 / 1 mm

end simulation



start patch Default

  # Randomize starting occupancy
  countOccupancy.init = sample uniform from 0 count to meta.constraints.maxOccupants
  initialACount.init = (sample uniform from 0% to 100%) * countOccupancy
  initialBCount.init = countOccupancy - initialACount

  # Create initial occupants
  SpeciesA.init = create initialACount of SpeciesA
  SpeciesB.init = create initialBCount of SpeciesB

  # Remove dead occupants at start of simulation step
  SpeciesA.start = prior.SpeciesA[prior.SpeciesA.dead == false]
  SpeciesB.start = prior.SpeciesB[prior.SpeciesB.dead == false]
  speciesACount.start = count(SpeciesA)
  speciesBCount.start = count(SpeciesB)
  totalCount.start = speciesACount + speciesBCount

  # Determine if in an extreme temperature event
  inExtremeTemperature.step = {
    const currentTemperature = external temperature
# Comment: I think these should be using the constants from above?
    const inExtremeCold = currentTemperature < constraints.minViableTemperature
    const inExtremeHot = currentTemperature > constraints.maxViableTemperature
    return inExtremeCold or inExtremeHot
  }

  # Calculate num new occupants end step (to have their first step on next step)
  newCount.end = {
    const probabilityNewRaw = (-1 count * (totalCount - 5 count) ^ 2 / 20 count) + 110 %
    const probabilityNew = limit probabilityNewRaw to [0%, 100%]
    const maxNewCount = (meta.constraints.maxOccupants - totalCount) * probabilityNew
    return sample uniform from 0 count to maxNewCount
  }

  # Work around division by zero to determine new species counts
  newSpeciesACount.end = {
    if (totalCount > 0) {
      return floor((speciesACount / totalCount) * newCount)
    } else {
      return newCount * 50%
    }
  }
  
  newSpeciesBCount.end = {
    if (totalCount > 0) {
      return floor((speciesACount / totalCount) * newCount)
    } else {
      return newCount * 50%
    }
  }

  # Make the new agents and concatenate to ("|" or add to end of) the current list.
  SpeciesA.end = prior.SpeciesA | create newSpeciesACount of SpeciesA
  SpeciesB.end = prior.SpeciesB | create newSpeciesBCount of SpeciesB

end patch


start organism SpeciesA

  # Agent implements behavior described in markdown
  # This responds to temperature and precipitation

  # Start a zero height except when if this is the simulation start
  dead.init = false
  height.init = {
    const isFirstYear = meta.startYear == meta.year
    const heightSample = sample normal with mean of 20 meters std of 5 meters
    const heightSampleLimit = limit heightSample to [0 meters, 40 meters]
    return heightSampleLimit if isFirstYear else 0 meters
  }

  # At each step, determine impact of temperature
  temperatureImpact.step = {
    const deltaFromOptimalTemp = external temperature - meta.optimal.temperature.speciesA
    return meta.growthScaler * (deltaFromOptimalTemp)^2
  }

  # At each step, determine impact of precipitation
# Comment: This is the implementation of our precipitation equation right? I think for readability reformulating this such that it is clear it is a sigmoid function would be nice but ot a priority for now (I think we also failed to explain that in the doc)
  precipitationImpact.step = {
    const deltaFromOptimalPrecipitation = external precipitation - meta.optimal.precip.speciesA
    const scaledPrecipitation = meta.precipitationScale * deltaFromOptimalPrecipitation
    return 1 / meta.precipitationBase ^ scaledPrecipitation
  }

  # At each step, determine overall growth
  newGrowth.step = (1 m - temperatureImpact) * precipitationImpact
  height.step = prior.height + newGrowth

  # At each step end, determine death
  dead.end = (sample uniform from 0% to 100%) > meta.survival.speciesA

end organism


start organism SpeciesB

  # Same as species A which, for toy demo, is same but with different constants
  # In practice, these two would likely have more divergent behaviors.

  # Start a zero height except when if this is the simulation start
  dead.init = false
  height.init = {
    const isFirstYear = meta.startYear == meta.year
    const heightSample = sample normal with mean of 20 meters std of 5 meters
    const heightSampleLimit = limit heightSample to [0 meters, 40 meters]
    return heightSampleLimit if isFirstYear else 0 meters
  }

  # At each step, determine impact of temperature
  temperatureImpact.step = {
    const deltaFromOptimalTemp = external temperature - meta.optimal.temperature.speciesB
# Comment: I am not sure I understand how this equation is implemented. The equation is g* - b(T-T*)^2, where is g* here?
    return meta.growthScaler * (deltaFromOptimalTemp)^2
  }

  # At each step, determine impact of precipitation
  precipitationImpact.step = {
# Comment: Ooh I get it now, the precipitationBase is used to calculate the exponential? Ok, but why is the scale factor in the Numerator?
# Comment: Hm hm, I am not sure if this is the most intuitive way to do this, but if it is correct I am trusting you to explain it :)
    const deltaFromOptimalPrecipitation = external precipitation - meta.optimal.precip.speciesB
    const scaledPrecipitation = meta.precipitationScale * deltaFromOptimalPrecipitation
    return 1 / meta.precipitationBase ^ scaledPrecipitation
  }

  # At each step, determine overall growth
  newGrowth.step = (1 m - temperatureImpact) * precipitationImpact
  height.step = prior.height + newGrowth

  # At each step end, determine death
  dead.end = (sample uniform from 0% to 100%) > meta.survival.speciesB

end organism


start unit K

  alias Kelvins
  alias Kelvin

end unit


start unit C

  alias Celcius

  K = 272.15 + current

end unit


start unit mm

  alias millimeters
  alias millimeter

  m = current / 1000

end unit
